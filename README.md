# 1. How can I ensure that my code, program, or software is functional and secure?

During my first project, I concentrated on building strong unit tests using JUnit to confirm that every component of my program worked correctly. I wrote tests for each method in the Contact and ContactService classes to ensure they handled both typical cases and unexpected situations effectively. This approach was crucial for identifying and fixing issues early, ensuring that every part of the application functioned as expected.

To boost security, I added checks to validate all data inputs and manage errors smoothly. This was vital to avoid common security threats like injection attacks and data corruption. I also made it a practice to follow secure coding principles and regularly update my software dependencies to fix any known vulnerabilities.

# 2. How do I interpret user needs and incorporate them into a program?

The first project required a deep understanding of what users would expect from a contact management system. By interacting with potential users early in the design phase, I learned what functionalities were most importantâ€”adding, updating, deleting, and retrieving contact information.

To integrate these needs into the software, I designed the ContactService class to offer a user-friendly interface for interacting with contact details. Regular feedback sessions helped me refine these features, ensuring the software met user expectations and was easy to use. This process didn't just address immediate needs but also laid the groundwork for future updates based on user feedback.

# 3. How do I approach designing software?

My approach to software design in the first project began with clearly defining the necessary features for the contact management system. I used UML diagrams to map out how the Contact and ContactService classes would interact, which clarified the overall structure.

The development process was iterative, with continuous integration allowing for gradual improvements and consistent progress. I developed each feature separately, tested it thoroughly, and then integrated it into the main system. This modular method simplified testing and enhanced both the maintainability and scalability of the application.
